<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EcoFilter Pro — AI × 신소재 × 인터랙티브</title>
<meta name="description" content="AI와 신소재공학 기반 미세플라스틱 정화 컨셉 시연 — 고급 인터랙션과 대형 캔버스 게임 포함" />
<style>
/* -------------------------
   GLOBAL STYLES
   ------------------------- */
:root{
  --bg-1:#00121a;
  --bg-2:#002831;
  --panel:#052b2a;
  --glass: rgba(255,255,255,0.03);
  --accent:#00d28a;
  --accent-2:#61b7ff;
  --muted:#9fc0c9;
  --card-radius:14px;
  --maxw:1200px;
  --mono: "Courier New", monospace;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: "Noto Sans KR", system-ui, -apple-system, Roboto, "Helvetica Neue", Arial;
  background: radial-gradient(800px 300px at 10% 8%, rgba(1,20,25,0.8), transparent),
              linear-gradient(180deg,var(--bg-1),var(--bg-2));
  color:#e7fbf4;
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
  overflow-x:hidden;
}

/* Container */
.container{max-width:var(--maxw); margin:36px auto; padding:20px}

/* HEADER */
.header{
  display:flex; align-items:center; justify-content:space-between; gap:12px;
  margin-bottom:18px;
}
.brand{
  display:flex; gap:12px; align-items:center;
}
.logo{
  width:64px; height:64px; border-radius:12px;
  background: linear-gradient(135deg,var(--accent),var(--accent-2));
  display:flex; align-items:center; justify-content:center; font-weight:900; color:#001218; font-size:20px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.6), inset 0 -6px 18px rgba(255,255,255,0.06);
}
.title{
  font-weight:800; font-size:18px;
}
.subtitle{color:var(--muted); font-size:13px; margin-top:4px}

/* LAYOUT: 2-column hero */
.hero{
  display:grid; grid-template-columns: 1fr 520px; gap:26px; align-items:start;
  margin-bottom:22px;
}
.card{
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  border-radius: var(--card-radius);
  padding:20px; box-shadow: 0 12px 50px rgba(0,0,0,0.6);
  border:1px solid rgba(255,255,255,0.03);
}

/* HERO LEFT */
h1.big{
  margin:0; font-size:28px; letter-spacing:-0.6px; line-height:1.05;
}
.lead{color:var(--muted); margin-top:10px; font-size:14px}

/* CTA */
.cta-row{display:flex; gap:10px; margin-top:16px}
.btn{
  background:linear-gradient(90deg,var(--accent),var(--accent-2));
  color:#001218; border:none; padding:12px 16px; border-radius:10px; font-weight:700; cursor:pointer;
  box-shadow: 0 8px 30px rgba(0,0,0,0.45);
}
.btn.ghost{background:transparent; color:var(--accent-2); border:1px solid rgba(255,255,255,0.04);}

/* RIGHT: preview panel */
.preview{
  display:flex; flex-direction:column; gap:14px; height:100%;
}
.preview .stat{
  background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
  padding:12px; border-radius:12px; display:flex; justify-content:space-between; align-items:center;
}
.stat .num{font-weight:800; font-size:20px}
.stat small{color:var(--muted)}

/* SECTIONS */
.section{display:grid; grid-template-columns: 1fr 420px; gap:20px; margin-bottom:22px}
.section.single{grid-template-columns: 1fr}
.section .left{min-height:220px}
.intro h3{margin:0 0 8px 0}
.p{color:var(--muted); line-height:1.5; font-size:14px}

/* AI SIM PANEL */
.ai-panel{padding:14px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.015), transparent); border:1px solid rgba(255,255,255,0.02)}
.sim-controls{display:flex; gap:8px; align-items:center; margin-top:10px}
.sim-output{margin-top:12px; font-family:var(--mono); font-size:13px; color:#cff3e7; background: rgba(0,0,0,0.12); padding:12px; border-radius:8px; max-height:160px; overflow:auto}

/* CANVAS WRAPPERS */
.canvas-wrap{background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border-radius:12px; padding:12px; position:relative; overflow:hidden; border:1px solid rgba(255,255,255,0.03)}

/* LARGE GAME AREA */
.game-area{
  width:100%; height:520px; border-radius:10px; overflow:hidden; position:relative; background: linear-gradient(180deg,#022a2a,#00121a);
  display:flex; align-items:center; justify-content:center;
}
.overlay-ui{position:absolute; left:16px; top:16px; z-index:20; display:flex; gap:8px; flex-direction:column}
.stat-pill{background:rgba(0,0,0,0.25); padding:8px 10px; border-radius:10px; font-weight:700; color:#dffbea; backdrop-filter: blur(3px)}
.controls{position:absolute; right:16px; bottom:16px; z-index:20; display:flex; gap:8px}
.small-btn{background:rgba(255,255,255,0.03); color:var(--accent-2); border:none; padding:8px 10px; border-radius:8px; font-weight:700; cursor:pointer}

/* INFO PANEL */
.info{
  display:flex; flex-direction:column; gap:10px;
}
.item{background:var(--glass); padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,0.02)}

/* FOOTER */
footer{margin-top:22px; text-align:center; color:var(--muted); font-size:13px}

/* RESPONSIVE */
@media (max-width:1100px){
  .hero{grid-template-columns:1fr}
  .section{grid-template-columns:1fr}
  .preview{order:2}
}

/* fancy micro-animation */
.wave{
  position:absolute; left:-10%; bottom:-8%; width:120%; height:60%;
  background: radial-gradient(600px 200px at 50% 50%, rgba(97,183,255,0.06), transparent);
  transform: rotate(-6deg);
  filter: blur(12px);
  pointer-events:none;
  z-index:1;
}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="brand">
      <div class="logo">EF</div>
      <div>
        <div class="title">EcoFilter Pro</div>
        <div class="subtitle">AI × 신소재공학 — 미세플라스틱 정화 인터랙티브 데모</div>
      </div>
    </div>
    <div style="text-align:right">
      <div style="font-weight:700">하은 김 — 제출용 데모</div>
      <div class="subtitle">신소재공학 · 화학공학 관점</div>
    </div>
  </div>

  <!-- HERO -->
  <div class="hero">
    <div class="card">
      <h1 class="big">자기회수형 친환경 신소재 필터<br><small style="font-weight:600;color:var(--muted)">AI가 설계하고, 사람이 체험하는 인터랙티브 데모</small></h1>
      <p class="lead">미세플라스틱을 흡착해 자석으로 회수하는 신소재 필터 컨셉을 AI 기반의 소재 탐색 시뮬레이션과 함께 시각화한다. 실시간 게임으로 원리 체험 가능.</p>
      <div class="cta-row">
        <button class="btn" id="playCTA">게임 시작 · 체험하기</button>
        <button class="btn ghost" id="openSim">AI 시뮬레이션 보기</button>
      </div>

      <div style="margin-top:18px; display:flex; gap:12px; align-items:center; flex-wrap:wrap">
        <div style="flex:1; min-width:220px">
          <div style="font-size:12px; color:var(--muted)">핵심 기술</div>
          <div style="font-weight:800; font-size:16px; margin-top:6px">자성 나노입자 · 바이오 기반 고분자 · 표면 개질</div>
        </div>
        <div style="width:1px; height:48px; background:rgba(255,255,255,0.02)"></div>
        <div style="min-width:180px">
          <div style="font-size:12px; color:var(--muted)">AI 역할</div>
          <div style="font-weight:800; font-size:16px; margin-top:6px">소재 조합 추천 · 구조 최적화 시뮬레이션</div>
        </div>
      </div>
    </div>

    <!-- RIGHT PREVIEW -->
    <div class="preview">
      <div class="stat card">
        <div style="display:flex; justify-content:space-between; align-items:center">
          <div>
            <div style="font-size:13px; color:var(--muted)">예상 흡착 효율(시뮬레이션)</div>
            <div class="num" id="simEff">-- %</div>
          </div>
          <div style="text-align:right">
            <small style="color:var(--muted)">추천 소재</small>
            <div style="font-weight:800" id="simCombo">-</div>
          </div>
        </div>
      </div>

      <div class="stat card">
        <div style="display:flex; justify-content:space-between; align-items:center">
          <div>
            <div style="font-size:13px; color:var(--muted)">현재 게임 최고점</div>
            <div class="num" id="bestScore">0</div>
          </div>
          <div style="text-align:right">
            <small style="color:var(--muted)">플레이어</small>
            <div style="font-weight:800">Visitor</div>
          </div>
        </div>
      </div>

      <div class="card" style="padding:14px">
        <div style="font-size:13px; color:var(--muted)">직접 작성 문구</div>
        <div style="font-weight:800; margin-top:8px">“AI는 우리가 상상하는 지속 가능한 세상을 구체화하는 협력자입니다.”</div>
      </div>
    </div>
  </div>

  <!-- SECTION: Problem & Idea + Game -->
  <div class="section">
    <div class="left card intro">
      <h3>1) 문제의식</h3>
      <p class="p">미세플라스틱은 바다와 하천의 생태계에 장기적으로 잔류하여 생물 다양성을 위협하고, 먹이사슬을 통해 인간 건강에도 미세한 영향을 준다. 특히 크기가 작을수록 전통적 물리적 필터에서 회수하기 어렵고, 대규모 처리 공정에서 비용과 에너지 부담이 크다. 따라서 흡착 효율이 높고 재사용 가능한 친환경 소재 설계가 필요하다.</p>

      <h3 style="margin-top:14px">2) 핵심 아이디어</h3>
      <p class="p">‘자기회수형 친환경 신소재 필터’는 자성 나노입자(예: Fe₃O₄ 계열)와 바이오 기반 고분자(키토산, 셀룰로오스 유도체)를 복합화하여 미세플라스틱 결합 친화적 표면을 만든다. 자성 성분을 이용해 필터를 원격 회수하고, AI를 통해 조성 및 표면처리 조건을 예측·최적화한다. 화학공정 기술을 적용하면 모듈형 플랜트에 통합 가능하다.</p>
    </div>

    <div class="right card">
      <h3 style="margin:0 0 8px 0">미니게임: Microplastic Collector</h3>
      <div class="p">아래 게임에서 자석 필터를 조작해 떨어지는 미세플라스틱을 잡아 점수를 획득하세요. 다양한 입자가 있고 일부는 '유해 오염물'으로 점수에 페널티를 준다. 게임은 데모이므로 물리법칙을 단순화하여 체감과 재미를 강화했습니다.</div>
      <div style="margin-top:12px; display:flex; gap:8px">
        <button class="btn" id="startGameBtn">게임 시작</button>
        <button class="btn ghost" id="howBtn">플레이 방법</button>
      </div>
    </div>
  </div>

  <!-- SECTION: Large Game Canvas + AI Panel -->
  <div class="section single">
    <div class="card">
      <div class="game-area canvas-wrap" id="gameRoot">
        <canvas id="gameCanvas" width="1200" height="520" style="width:100%; height:520px; display:block"></canvas>

        <div class="wave"></div>

        <div class="overlay-ui">
          <div class="stat-pill">시간: <span id="timeLeft">--</span>s</div>
          <div class="stat-pill">점수: <span id="score">0</span></div>
          <div class="stat-pill">에너지: <span id="energy">---</span></div>
        </div>

        <div class="controls">
          <button class="small-btn" id="toggleMag">자기장 ON</button>
          <button class="small-btn" id="pauseBtn">일시정지</button>
          <button class="small-btn" id="resetBtn">초기화</button>
        </div>
      </div>

      <div style="display:flex; gap:12px; margin-top:12px; flex-wrap:wrap">
        <div class="item" style="flex:1">
          <strong>게임 규칙</strong>
          <div class="p" style="margin-top:6px">마우스/터치로 필터(하단)를 좌우로 이동하세요. 자기장을 켜면 자성입자(특정 플라스틱)를 끌어당깁니다. 에너지를 소모하며, 유해 입자를 잡으면 점수가 감소합니다. 목표: 제한시간 내 최대 점수.</div>
        </div>
        <div class="item" style="width:300px">
          <strong>최고 기록</strong>
          <div id="bestBoard" style="margin-top:8px; font-family:var(--mono); color:#c8fff0">—</div>
        </div>
      </div>
    </div>
  </div>

  <!-- AI SIMULATION + VISUALIZATION -->
  <div class="section">
    <div class="left card ai-panel">
      <h3 style="margin:0">AI 시뮬레이션 모듈 (모사)</h3>
      <div class="p" style="margin-top:8px">데모 AI는 소재 조합을 탐색하는 단순한 유전 알고리즘(모사)을 실행해 '흡착 효율'을 예측한다. 실제 실험 데이터가 없는 환경에서 AI가 어떻게 후보를 제안하는지 시각적으로 보여주기 위한 목적이다.</div>

      <div class="sim-controls">
        <label style="font-size:13px; color:var(--muted)">세대 수</label>
        <input id="genCount" type="range" min="10" max="200" value="80" style="flex:1"/>
        <button class="btn" id="runSim">시뮬레이션 실행</button>
      </div>

      <div class="sim-output" id="simLog">준비 완료. '시뮬레이션 실행' 버튼을 누르세요.</div>
    </div>

    <div class="right card">
      <h3 style="margin:0 0 8px 0">시각화</h3>
      <div class="p">AI가 생성한 상위 후보들의 흡착 효율을 그래프로 표시합니다. 또한 추천된 후보 하나의 표면 구조(스케치)를 간단한 캔버스로 렌더링합니다.</div>

      <div style="margin-top:12px">
        <canvas id="simChart" width="420" height="200" style="width:100%; height:200px;"></canvas>
      </div>
      <div style="margin-top:12px">
        <canvas id="surfaceSketch" width="420" height="120" style="width:100%; height:120px;"></canvas>
      </div>
    </div>
  </div>

  <!-- REFLECTION -->
  <div class="section single">
    <div class="card">
      <h3>성찰</h3>
      <p class="p">이번 데모를 만들며 신소재공학의 재료 설계, 화학공학의 공정 통합, 그리고 AI의 탐색·최적화 역할을 직접 연결해 보았다. 실험 데이터를 가진 실제 연구와는 다르게, AI 시뮬레이션은 모사이지만 개념 증명(proof-of-concept)으로는 충분하다. 향후 실제 물성 데이터와 결합하면 실용적 설계가 가능하다.</p>
    </div>
  </div>

  <footer>© EcoFilter Pro — Demo · 하은 김</footer>
</div>

<!-- ================================
     JAVASCRIPT: GAME + AI SIM + UI
     ================================ -->
<script>
/* =================================================
   유틸 + 상태
   ================================================= */
const $ = (s) => document.querySelector(s);
const simEffEl = $('#simEff');
const simComboEl = $('#simCombo');
const simLog = $('#simLog');
const simChart = document.getElementById('simChart');
const surfaceSketch = document.getElementById('surfaceSketch');
const bestScoreEl = $('#bestScore');
const bestBoard = $('#bestBoard');

// 로컬 최고기록 불러오기
let bestScore = parseInt(localStorage.getItem('eco_best_score') || '0', 10);
bestScoreEl.textContent = bestScore;
bestBoard.textContent = bestScore > 0 ? `${bestScore} 점 (로컬)` : '기록 없음';

/* =================================================
   GAME: 캔버스 기반 물리 단순화 (입자 낙하 + 자기장)
   ================================================= */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// 디바이스 픽셀비 고려
function fitCanvas(){
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * devicePixelRatio);
  canvas.height = Math.floor(rect.height * devicePixelRatio);
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

const G = 300; // 중력(속도)
const width = () => canvas.width / devicePixelRatio;
const height = () => canvas.height / devicePixelRatio;

let gameState = {
  playing:false,
  timeLeft:30,
  score:0,
  energy:100,
  magOn:false,
  particles:[],
  filterX: null
};

// 필터(플레이어)
const filter = {
  width:140,
  height:22,
  y: height() - 40,
  x: 0,
  vel:0
};

// 마우스/터치 제어
let pointerX = width()/2;
function updatePointer(e){
  let rx;
  if(e.touches && e.touches[0]) rx = e.touches[0].clientX;
  else rx = e.clientX;
  const rect = canvas.getBoundingClientRect();
  pointerX = Math.max(20, Math.min(rect.width-20, rx - rect.left));
}
window.addEventListener('pointermove', updatePointer);
window.addEventListener('touchmove', updatePointer, {passive:true});

// 입자 타입 정의
const PARTICLE_TYPES = [
  {name:'플라스틱(유동)', color1:'#b4e0ff', color2:'#007a5e', radius:8, mass:1, score:10, magnetic:true},
  {name:'플라스틱(미세)', color1:'#ffd99b', color2:'#ff8a00', radius:5, mass:0.6, score:7, magnetic:true},
  {name:'유해오염물', color1:'#ff7f7f', color2:'#a10000', radius:10, mass:1.5, score:-15, magnetic:false},
  {name:'유기입자', color1:'#d2b7ff', color2:'#6f42c1', radius:12, mass:1.2, score:5, magnetic:false}
];

// 랜덤 입자 생성
function spawnParticle(){
  const t = PARTICLE_TYPES[Math.floor(Math.random()*PARTICLE_TYPES.length)];
  // 위치는 상단 랜덤
  const p = {
    x: Math.random() * (width()-40) + 20,
    y: -20,
    vx: (Math.random()-0.5) * 40,
    vy: 40 + Math.random()*30,
    r: t.radius,
    color1: t.color1,
    color2: t.color2,
    mass: t.mass,
    scoreVal: t.score,
    magnetic: t.magnetic,
    life: 0
  };
  gameState.particles.push(p);
}

// 게임 루프
let lastTime = performance.now();
function gameLoop(now){
  const dt = Math.min(0.04, (now - lastTime) / 1000);
  lastTime = now;
  update(dt);
  render();
  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

// 업데이트
function update(dt){
  // filter x 업데이트 (매끄럽게 추적)
  if(gameState.filterX === null) gameState.filterX = width()/2;
  const targetX = pointerX;
  gameState.filterX += (targetX - gameState.filterX) * Math.min(12*dt, 1);

  // spawn율 컨트롤
  if(gameState.playing && Math.random() < 0.06 + Math.min(0.18, (30-gameState.timeLeft)/30*0.2)) {
    spawnParticle();
  }

  // 입자 물리
  for(let i = gameState.particles.length-1; i>=0; i--){
    const p = gameState.particles[i];
    // 중력 (속도로 취급)
    p.vy += G * dt * 0.2 * (1/p.mass);
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life += dt;

    // 자기장 효과: 자성이 있고 자기장이 켜져 있으며, 필터에 일정거리 이내면 끌어당김
    if(gameState.magOn && p.magnetic){
      const dx = (gameState.filterX) - p.x;
      const dy = (filter.y - 8) - p.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist < 220){
        // 거리 기반 끌림
        const force = (200 - dist) / 200;
        p.vx += (dx / Math.max(dist,1)) * force * 150 * dt;
        p.vy += (dy / Math.max(dist,1)) * force * 180 * dt;
        // 자기장 사용시 에너지 소모
        gameState.energy = Math.max(0, gameState.energy - 12 * dt);
        if(gameState.energy <= 0){
          gameState.magOn = false;
        }
      }
    }

    // 경계 처리
    if(p.x < 10) { p.x = 10; p.vx *= -0.3 }
    if(p.x > width()-10) { p.x = width()-10; p.vx *= -0.3 }

    // 충돌: 필터에 닿으면 처리
    const filterRect = {x: gameState.filterX - filter.width/2, y: filter.y - filter.height/2, w:filter.width, h:filter.height};
    if(p.y + p.r >= filterRect.y && p.x > filterRect.x && p.x < filterRect.x + filterRect.w){
      // 잡힘
      // 점수 반영
      gameState.score += p.scoreVal;
      // 잡으면 작게 튕기거나 제거. 유해오염물은 파괴음/효과 가능
      gameState.particles.splice(i,1);
      continue;
    }

    // 화면 아래로 빠지면 제거
    if(p.y > height() + 50 || p.life > 25){
      gameState.particles.splice(i,1);
    }
  }

  // 시간 흐름
  if(gameState.playing){
    gameState.timeLeft -= dt;
    if(gameState.timeLeft <= 0){
      endGame();
    }
  }
  updateHUD();
}

// 렌더
function render(){
  // 배경
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // 바닥 그라디언트
  const w = width(), h = height();
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'rgba(2,40,40,0.6)');
  g.addColorStop(1,'rgba(0,10,18,0.95)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,w,h);

  // 시각적 강물 흐름 (선)
  for(let i=0;i<5;i++){
    ctx.beginPath();
    ctx.strokeStyle = `rgba(97,183,255,${0.02 + i*0.014})`;
    ctx.lineWidth = 1 + i*0.5;
    ctx.moveTo(0, h*0.2 + Math.sin(Date.now()/1000 + i) * 12,);
    for(let x=0;x<w;x+=40){
      ctx.lineTo(x, h*0.2 + Math.sin((x/100) + Date.now()/1200 + i) * (24 + i*6));
    }
    ctx.stroke();
  }

  // particles
  gameState.particles.forEach(p=>{
    // radial gradient
    const rad = ctx.createRadialGradient(p.x, p.y, p.r*0.2, p.x, p.y, p.r*1.6);
    rad.addColorStop(0, p.color1);
    rad.addColorStop(1, p.color2);
    ctx.fillStyle = rad;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();

    // small shine
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.beginPath();
    ctx.ellipse(p.x - p.r*0.3, p.y - p.r*0.45, p.r*0.5, p.r*0.25, 0, 0, Math.PI*2);
    ctx.fill();
  });

  // 필터 그리기 (플레이어)
  const fx = gameState.filterX;
  const fy = filter.y;
  // filter shadow
  ctx.beginPath();
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.ellipse(fx, fy + 18, filter.width*0.6, 10, 0, 0, Math.PI*2);
  ctx.fill();

  // filter body
  ctx.beginPath();
  const grd = ctx.createLinearGradient(fx - filter.width/2, fy - 10, fx + filter.width/2, fy + 10);
  grd.addColorStop(0, '#007a5e');
  grd.addColorStop(1, '#00d28a');
  ctx.fillStyle = grd;
  roundRect(ctx, fx - filter.width/2, fy - filter.height/2, filter.width, filter.height, 10);
  ctx.fill();

  // 필터 강조선
  ctx.beginPath();
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 2;
  roundRect(ctx, fx - filter.width/2+2, fy - filter.height/2+2, filter.width-4, filter.height-4, 8);
  ctx.stroke();

  // 자기장 파동
  if(gameState.magOn){
    const pulse = 1 + Math.sin(Date.now()/220) * 0.08;
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(97,183,255,0.08)';
    ctx.lineWidth = 1.8;
    ctx.ellipse(fx, fy - 80, 160*pulse, 70*pulse, 0, 0, Math.PI*2);
    ctx.stroke();
  }
}

// helper: rounded rect path
function roundRect(ctx, x, y, w, h, r){
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}

// HUD 업데이트
function updateHUD(){
  $('#timeLeft').textContent = Math.max(0, Math.ceil(gameState.timeLeft));
  $('#score').textContent = gameState.score;
  $('#energy').textContent = Math.max(0, Math.floor(gameState.energy));
  $('#energy').style.color = gameState.energy < 30 ? '#ff8a8a' : '#caffdd';
}

/* GAME CONTROL API */
function startGame(duration=30){
  // reset
  gameState.playing = true;
  gameState.timeLeft = duration;
  gameState.score = 0;
  gameState.energy = 100;
  gameState.particles = [];
  gameState.magOn = false;
  gameState.filterX = width()/2;
  lastTime = performance.now();
}
function endGame(){
  gameState.playing = false;
  // 최고기록 저장
  if(gameState.score > bestScore){
    bestScore = gameState.score;
    localStorage.setItem('eco_best_score', String(bestScore));
    bestScoreEl.textContent = bestScore;
    bestBoard.textContent = `${bestScore} 점 (로컬)`;
    alert(`새 기록! ${bestScore} 점`);
  } else {
    alert(`게임 종료. 점수: ${gameState.score}`);
  }
}
function toggleMag(){
  if(gameState.energy <= 0){ gameState.magOn = false; return; }
  gameState.magOn = !gameState.magOn;
  $('#toggleMag').textContent = gameState.magOn ? '자기장 OFF' : '자기장 ON';
}
function pauseToggle(){
  gameState.playing = !gameState.playing;
  document.getElementById('pauseBtn').textContent = gameState.playing ? '일시정지' : '재개';
}
function resetGame(){
  gameState.playing = false;
  gameState.particles = [];
  gameState.score = 0;
  gameState.timeLeft = 30;
  gameState.energy = 100;
  updateHUD();
}

/* 버튼 바인딩 */
$('#startGameBtn').addEventListener('click', ()=> startGame(30));
$('#playCTA').addEventListener('click', ()=> {
  window.scrollTo({top: document.querySelector('#game').offsetTop, behavior:'smooth'});
  startGame(30);
});
$('#toggleMag').addEventListener('click', toggleMag);
$('#pauseBtn').addEventListener('click', pauseToggle);
$('#resetBtn').addEventListener('click', resetGame);
$('#howBtn').addEventListener('click', ()=> alert('마우스/터치로 필터를 좌우로 이동하세요. 자기장을 켜면 자성입자를 끌어당깁니다. 유해입자는 피하세요.'))


/* =================================================
   AI SIMULATION (간단한 유전알고리즘 모사)
   - candidate: {Fe_content, polymer_type, surface_roughness}
   - fitness: 모의 흡착 효율 (가중치 합 + 잡음)
   =================================================*/
function randRange(a,b){ return a + Math.random()*(b-a) }
function pickPolymer(){
  const list = ['키토산','셀룰로오스','PLA','알긴산','PVA'];
  return list[Math.floor(Math.random()*list.length)];
}
function randomCandidate(){
  return {
    fe: Math.round(randRange(5,60)), // Fe 함량 %
    polymer: pickPolymer(),
    rough: Math.round(randRange(1,100)) // surface roughness scale
  }
}
function fitness(c){
  // 가중치 설정 (임의)
  // Fe는 중간값 근처가 좋다 (자기성 + 과도한 Fe는 집합체 형성)
  const feScore = 1 - Math.abs(c.fe - 28)/28; // 1에 가까울수록 좋음
  const polymerScore = {'키토산':1.0,'셀룰로오스':0.9,'알긴산':0.92,'PLA':0.78,'PVA':0.82}[c.polymer] || 0.8;
  const roughScore = Math.tanh(c.rough/60); // 표면 거칠수록 표면적 증가 (포화)
  const base = 0.5*feScore + 0.35*polymerScore + 0.15*roughScore;
  // 잡음 + 약간의 랜덤 보정
  return Math.max(0, base + (Math.random()-0.45)*0.07);
}

/* 유전 알고리즘 단순 구현 */
function runSim(generations=80, popSize=60, onProgress){
  let pop = [];
  for(let i=0;i<popSize;i++) pop.push(randomCandidate());
  let best = null;
  let logs = [];
  for(let g=0; g<generations; g++){
    // 평가
    const scored = pop.map(p=>({p,score: fitness(p)}));
    scored.sort((a,b)=>b.score - a.score);
    if(!best || scored[0].score > best.score){
      best = {candidate:scored[0].p, score:scored[0].score, gen:g};
    }
    // 기록용
    logs.push({gen:g, bestScore:scored[0].score, avg: scored.reduce((s,x)=>s+x.score,0)/scored.length});
    // 선택 (엘리트 보존)
    const elite = scored.slice(0, Math.max(2, Math.floor(popSize*0.08))).map(x=>x.p);
    // 교차 + 변이로 다음세대
    const next = [...elite];
    while(next.length < popSize){
      // 토너먼트 선택
      const a = scored[Math.floor(Math.random()*Math.floor(popSize*0.6))].p;
      const b = scored[Math.floor(Math.random()*Math.floor(popSize*0.6))].p;
      // 교차
      const child = {
        fe: Math.round((a.fe + b.fe)/2 + (Math.random()-0.5)*6),
        polymer: Math.random()<0.5 ? a.polymer : b.polymer,
        rough: Math.round((a.rough + b.rough)/2 + (Math.random()-0.5)*8)
      };
      // 변이
      if(Math.random() < 0.12) child.fe = Math.round(child.fe + (Math.random()-0.5)*18);
      if(Math.random() < 0.12) child.rough = Math.max(1, Math.min(100, child.rough + (Math.random()-0.5)*40));
      if(Math.random() < 0.06) child.polymer = pickPolymer();
      // clamp
      child.fe = Math.max(3, Math.min(75, child.fe));
      next.push(child);
    }
    pop = next;
    if(onProgress) onProgress({gen:g, best:best, logs:logs});
  }
  return {best, logs};
}

/* UI: 시뮬레이션 실행 */
$('#runSim').addEventListener('click', ()=> {
  const gens = parseInt($('#genCount').value,10);
  simLog.textContent = '시뮬레이션 시작... 잠시 기다려주세요.';
  // 비동기적으로 루프를 돌려 UI 업데이트 (하지만 외부 호출 없음)
  setTimeout(()=> {
    const out = runSim(gens, 80, function(progress){
      // 진행 로그를 간헐적으로 보여주기 (마지막만 반영)
    });
    // 결과 반영
    const bestCand = out.best.candidate;
    const bestScoreVal = Math.round(out.best.score * 100);
    simLog.innerHTML = `탐색 완료.<br>최종 추천 후보: <strong>${bestCand.fe}% Fe + ${bestCand.polymer} + rough ${bestCand.rough}</strong><br>예상 흡착 효율(모사): <strong>${bestScoreVal}%</strong>`;
    simEffEl.textContent = `${bestScoreVal}%`;
    simComboEl.textContent = `${bestCand.fe}% Fe + ${bestCand.polymer}`;
    // 그래픽으로 로그 표현
    drawSimChart(out.logs);
    drawSurfaceSketch(bestCand);
  }, 50);
});

/* 차트 그리기 (간단 막대/선 혼합) */
function drawSimChart(logs){
  const c = simChart;
  const g = c.getContext('2d');
  const w = c.width, h = c.height;
  g.clearRect(0,0,w,h);
  // 픽셀비 고려
  const dpr = devicePixelRatio || 1;
  c.width = c.clientWidth * dpr;
  c.height = c.clientHeight * dpr;
  g.setTransform(dpr,0,0,dpr,0,0);

  const n = logs.length;
  const pad = 18;
  // 배경
  g.fillStyle = 'rgba(0,0,0,0.06)';
  g.fillRect(0,0,c.clientWidth, c.clientHeight);

  // 경계선
  g.strokeStyle = 'rgba(255,255,255,0.06)';
  g.beginPath(); g.moveTo(pad, pad); g.lineTo(pad, c.clientHeight-pad); g.lineTo(c.clientWidth-pad, c.clientHeight-pad); g.stroke();

  // 선 데이터 (bestScore)
  const maxVal = Math.max(...logs.map(l=>l.bestScore)) || 1;
  g.beginPath();
  for(let i=0;i<n;i++){
    const x = pad + (i/(n-1)) * (c.clientWidth - pad*2);
    const y = c.clientHeight - pad - (logs[i].bestScore / maxVal) * (c.clientHeight - pad*2);
    if(i===0) g.moveTo(x,y); else g.lineTo(x,y);
  }
  g.strokeStyle = '#61b7ff';
  g.lineWidth = 2;
  g.stroke();

  // 작은 점들
  for(let i=0;i<n;i++){
    const x = pad + (i/(n-1)) * (c.clientWidth - pad*2);
    const y = c.clientHeight - pad - (logs[i].bestScore / maxVal) * (c.clientHeight - pad*2);
    g.fillStyle = 'rgba(97,183,255,0.9)';
    g.beginPath(); g.arc(x,y,2.4,0,Math.PI*2); g.fill();
  }

  // 레이블
  g.fillStyle = 'rgba(255,255,255,0.8)';
  g.font = '12px sans-serif';
  g.fillText('세대 →', c.clientWidth - pad - 50, c.clientHeight - pad + 14);
  g.fillText('흡착 효율(상대)', 8, pad + 10);
}

/* 표면 스케치 (추상적) */
function drawSurfaceSketch(candidate){
  const c = surfaceSketch;
  const g = c.getContext('2d');
  const dpr = devicePixelRatio || 1;
  c.width = c.clientWidth * dpr;
  c.height = c.clientHeight * dpr;
  g.setTransform(dpr,0,0,dpr,0,0);
  g.clearRect(0,0,c.clientWidth,c.clientHeight);

  // 배경
  g.fillStyle = 'rgba(0,0,0,0.04)';
  roundRectPath(g,4,4,c.clientWidth-8,c.clientHeight-8,8);
  g.fill();

  // roughness에 따라 점/구조 밀도 변화
  const rough = candidate.rough;
  const count = Math.round(20 + rough/2);
  for(let i=0;i<count;i++){
    const x = 10 + Math.random()*(c.clientWidth-20);
    const y = 10 + Math.random()*(c.clientHeight-20);
    const size = 1 + (Math.random()*(rough/30));
    g.fillStyle = `rgba(160,240,210,${0.12 + Math.random()*0.3})`;
    g.beginPath(); g.arc(x,y,size,0,Math.PI*2); g.fill();
  }

  // 후보 텍스트
  g.fillStyle = '#c7fff0';
  g.font = '12px sans-serif';
  g.fillText(`${candidate.fe}% Fe · ${candidate.polymer} · rough ${candidate.rough}`, 12, c.clientHeight - 10);
}
function roundRectPath(g,x,y,w,h,r){
  g.beginPath();
  g.moveTo(x + r, y);
  g.arcTo(x + w, y, x + w, y + h, r);
  g.arcTo(x + w, y + h, x, y + h, r);
  g.arcTo(x, y + h, x, y, r);
  g.arcTo(x, y, x + w, y, r);
  g.closePath();
}

/* 초기 기본 시뮬레이션 자동 실행 */
setTimeout(()=> {
  // 기본 빠른 실행으로 대시보드 채움
  const out = runSim(60, 70);
  const best = out.best;
  simLog.textContent = `자동 탐색 완료. 추천: ${best.candidate.fe}% Fe + ${best.candidate.polymer} / 예측 효율: ${Math.round(best.score*100)}%`;
  simEffEl.textContent = `${Math.round(best.score*100)}%`;
  simComboEl.textContent = `${best.candidate.fe}% Fe + ${best.candidate.polymer}`;
  drawSimChart(out.logs);
  drawSurfaceSketch(best.candidate);
}, 200);

/* =================================================
   초깃값 및 보조(게임 루프와 UI 동기)
   =================================================*/
(function init(){
  // 필터 y 위치 재계산
  filter.y = height() - 40;
  // pointer 초기화
  gameState.filterX = width()/2;
  // 렌더 루프는 위에서 이미 실행됨
})();

/* =================================================
   안전성: 페이지 숨김 시 일시정지
   =================================================*/
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden){
    if(gameState.playing) gameState.playing = false;
  }
});

/* =================================================
   끝.
   =================================================*/
</script>
</body>
</html>
